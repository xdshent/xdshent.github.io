---
layout:     post
title:      "抽象工厂模式"
date:       2021-03-11
author:     "xdshent"
catalog: true
tags:
    - 设计模式
---

## 定义

提供一个产品库, 所有产品以同样的接口出现, 从而客户端不依赖具体实现



## 应用场景

适用于需要生成产品族的情景



## UML

![](/img/assets/java-design-pattern/factory/abstract-factory.png)



## Java代码

```java
public class AbstractFactoryClient {
    public static void main(String[] args) {

        AbstractFactory factoryA = new FactoryA();
        factoryA.makeProductA().doA();
        factoryA.makeProductB().doB();

        AbstractFactory factoryB = new FactoryB();
        factoryB.makeProductA().doA();
        factoryB.makeProductB().doB();
    }

    /**
     * 抽象工厂类
     */
    public interface AbstractFactory{
        /**
         * 制造产品A
         */
        ProductA makeProductA();

        /**
         * 制造产品B
         */
        ProductB makeProductB();
    }

    /**
     * 抽象产品A
     */
    public interface ProductA{
        /**
         * 具体操作
         */
        void doA();
    }

    /**
     * 抽象产品B
     */
    public interface ProductB{
        /**
         * 具体操作
         */
        void doB();
    }

    static class ConcreteProductAWithFamilyA implements ProductA{

        @Override
        public void doA() {
            System.out.println("Product A with family A");
        }
    }

    static class ConcreteProductBWithFamilyA implements ProductB{

        @Override
        public void doB() {
            System.out.println("Product B with family A");
        }
    }

    static class ConcreteProductAWithFamilyB implements ProductA{

        @Override
        public void doA() {
            System.out.println("Product A with family B");
        }
    }

    static class ConcreteProductBWithFamilyB implements ProductB{

        @Override
        public void doB() {
            System.out.println("Product B with family B");
        }
    }

    static class FactoryA implements AbstractFactory{

        @Override
        public ProductA makeProductA() {

            return new ConcreteProductAWithFamilyA();
        }

        @Override
        public ProductB makeProductB() {

            return new ConcreteProductBWithFamilyA();
        }
    }

    static class FactoryB implements AbstractFactory{

        @Override
        public ProductA makeProductA() {

            return new ConcreteProductAWithFamilyB();
        }

        @Override
        public ProductB makeProductB() {

            return new ConcreteProductBWithFamilyB();
        }
    }
}
```



## 在Spring中的应用

在Spring中所有工厂都是BeanFactory的子类, 通过对BeanFactory的实现, 可以从Spring容器访问Bean.

> Spring中DefaultListableBeanFactory实现了所有工厂的公共逻辑

* ClassPathXmlApplicationContext
* XmlWebApplicationContext
* AnnotationConfigApplicationContext



## 优缺点

* 保证客户端只使用同一个产品的产品族
* 对新产品族的增加只需实现一个新的具体工厂即可
* 产品族扩展新产品困难, 需要修改抽象工厂接口
* 增加了系统的抽象性和理解难度