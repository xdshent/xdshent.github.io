---
layout:     post
title:      "工厂方法模式"
date:       2021-03-10
author:     "xdshent"
catalog: true
tags:
    - 设计模式
---

## 定义

不再由单一的工厂类生产产品, 而是由工厂类的子类实现具体产品的创建, 解决简单工厂生产太多产品导致的内部代码臃肿, 也符合开闭原则



## 应用场景

* 创建对象需要大量重复的代码
* 客户端不依赖产品类实例如何被创建、实现等细节
* 一个类通过其子类来指定创建哪个对象



## UML

![](/img/assets/java-design-pattern/factory/factory-method.png)



## Java代码

```java
public class FactoryMethodClient {

    public static void main(String[] args) {
        Factory factoryA = new FactoryA();
        factoryA.makeProduct().doSomething();

        Factory factoryB = new FactoryB();
        factoryB.makeProduct().doSomething();

        Factory factoryC = new FactoryC();
        factoryC.makeProduct().doSomething();
    }

    /**
     * 抽象产品
     */
    public interface Product{
        /**
         * 具体操作
         */
        void doSomething();
    }

    static class ProductA implements Product{

        @Override
        public void doSomething() {
            System.out.println("我是产品A");
        }
    }

    static class ProductB implements Product{

        @Override
        public void doSomething() {
            System.out.println("我是产品B");
        }
    }

    static class ProductC implements Product{

        @Override
        public void doSomething() {
            System.out.println("我是产品C");
        }
    }

    /**
     * 工厂
     */
    public interface Factory{
        /**
         * 制造产品
         * @return
         */
        Product makeProduct();
    }

    static class FactoryA implements Factory{

        @Override
        public Product makeProduct() {
            return new ProductA();
        }
    }

    static class FactoryB implements Factory{

        @Override
        public Product makeProduct() {
            return new ProductB();
        }
    }

    static class FactoryC implements Factory{

        @Override
        public Product makeProduct() {
            return new ProductC();
        }
    }
}
```



## Logback中的应用

![](/img/assets/java-design-pattern/factory/logger-factory-class.png)



## 优缺点

* 灵活性强, 新建产品只需写一个相应的工厂类
* 满足迪米特法则、依赖倒置、原则和里氏代换原则
* 类的个数容易过多增加复杂度
* 只能生产一种产品